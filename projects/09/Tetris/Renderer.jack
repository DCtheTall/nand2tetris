/** Renderer class is a static class that handles rendering game state to screen */
class Renderer {
    static int gridTop;
    static int gridLeft;
    static int cellSize;
    static int queueLeftMargin;
    static int scoreCursorRow;
    static int scoreCursorCol;

    function void init() {
        let gridTop = 6;
        let gridLeft = 50;
        let cellSize = 12;
        let queueLeftMargin = 20;
        let scoreCursorRow = 2;
        let scoreCursorCol = 35;
        return;
    }

    /** Render the game start */
    function void renderGameStart(GameState state) {
        var Grid grid;
        var int gridRight;
        var int gridBottom;

        let grid = state.getGrid();
        let gridRight = gridLeft + (grid.getWidth() * cellSize);
        let gridBottom = gridTop + (grid.getHeight() * cellSize);

        // Draw the outline of the grid
        do Screen.setColor(true);
        do Screen.drawLine(gridLeft - 1, gridTop - 1, gridRight + 1, gridTop - 1);
        do Screen.drawLine(gridLeft - 1, gridTop - 1, gridLeft - 1, gridBottom + 1);
        do Screen.drawLine(gridLeft - 1, gridBottom + 1, gridRight + 1, gridBottom + 1);
        do Screen.drawLine(gridRight + 1, gridTop - 1, gridRight + 1, gridBottom + 1);

        do Renderer.renderState(state);
        return;
    }

    /** Render the GameState to the screen */
    function void renderState(GameState state) {
        var Grid grid;
        var int queueLeft;
        let grid = state.getGrid();
        let queueLeft = gridLeft + (grid.getWidth() * cellSize) + queueLeftMargin;
        do Renderer.renderGrid(state.getGrid());
        do Renderer.renderBrickQueue(state, queueLeft);
        do Renderer.renderScore(state);
        do Renderer.renderGameOver(state);
        do Renderer.renderFallingBrick(state.getFallingBrick());
        return;
    }

    /** Render the grid of static blocks */
    function void renderGrid(Grid grid) {
        var int width;
        var int height;
        var int area;
        var int i;
        var int x;
        var int y;

        let width = grid.getWidth();
        let height = grid.getHeight();
        let area = width * height;

        // Draw white rectangle over entire grid.
        do Screen.setColor(false);
        do Screen.drawRectangle(
                gridLeft, gridTop, gridLeft + (cellSize * width), gridTop + (cellSize * height));

        let i = 0;
        while (i < area) {
            if (grid.cellAtIndex(i)) {
                let x = gridLeft + (cellSize * MathExt.mod(i, width));
                let y = gridTop + (cellSize * (i / width));
                do Renderer.renderBrickCell(x, y);
            }
            let i = i + 1;
        }

        return;
    }

    /** Render the queue of bricks to come */
    function void renderBrickQueue(GameState state, int queueLeft) {
        var BrickQueue queue;

        var int queueRight;
        var Grid grid;
        var int queueBottom;

        var int i;
        var int qSize;
        var Brick brickType;
        var int brickTypeSize;
        var int brickLeft;
        var int brickTop;

        let queue = state.getQueue();
        if (~queue.getShouldRender()) {
            return;
        }
        do queue.unsetShouldRender();

        // Draw a white rectangle over the current queue.
        let queueRight = queueLeft + (Brick.maxShapeSize() * cellSize);
        let grid = state.getGrid();
        let queueBottom = gridTop + (grid.getHeight() * cellSize);
        do Screen.setColor(false);
        do Screen.drawRectangle(queueLeft, gridTop + cellSize, queueRight, queueBottom);

        // Render each brick in the queue.
        let i = 0;
        let qSize = queue.getSize();
        while (i < qSize) {
            let brickType = queue.getBrickTypeAtIndex(i);
            let brickTypeSize = brickType.shapeSize();
            let brickLeft = queueLeft + ((cellSize * (Brick.maxShapeSize() - brickTypeSize)) / 2);
            let brickTop = cellSize + gridTop + (Brick.maxShapeSize() * i * cellSize);
            do Renderer.renderBrick(brickType, brickLeft, brickTop);
            let i = i + 1;
        }
        return;
    }

    /** Render a brick shape */
    function void renderBrick(Brick brick, int x, int y) {
        var int size;
        var int sizeSquared;
        var Array shape;
        var int i;
        var int curx;
        var int cury;

        let size = brick.shapeSize();
        let sizeSquared = size * size;
        let shape = brick.rotatedShape();

        let i = 0;
        while (i < sizeSquared) {
            if (shape[i]) {
                let curx = x + (MathExt.mod(i, size) * cellSize);
                let cury = y + ((i / size) * cellSize);
                do Renderer.renderBrickCell(curx, cury);
            }
            let i = i + 1;
        }
        do shape.dispose();
        return;
    }

    /** Render a single brick cell */
    function void renderBrickCell(int x, int y) {
        if (y < gridTop) {
            return;
        }
        do Screen.setColor(true);
        do Screen.drawRectangle(x, y, x + cellSize, y + cellSize);
        do Screen.setColor(false);
        do Screen.drawLine(x, y, x + cellSize, y);
        do Screen.drawLine(x, y, x, y + cellSize);
        return;
    }

    /** Render the score */
    function void renderScore(GameState state) {
        do Output.moveCursor(scoreCursorRow, scoreCursorCol);
        do Output.printString("              ");
        do Output.moveCursor(scoreCursorRow, scoreCursorCol);
        do Output.printString("Score: ");
        do Output.printInt(state.getScore());
        return;
    }

    /** Render the game over text */
    function void renderGameOver(GameState state) {
        if (~state.isGameOver()) {
            return;
        }
        do Output.moveCursor(scoreCursorRow + 1, scoreCursorCol);
        do Output.printString("Game over!");
        return;
    }

    /** Render the currently falling brick */
    function void renderFallingBrick(FallingBrick fallingBrick) {
        var int x;
        var int y;
        if (~fallingBrick.isSpawned()) {
            return;
        }
        let x = gridLeft + (fallingBrick.getX() * cellSize);
        let y = fallingBrick.getY() * cellSize - gridTop;
        do Renderer.renderBrick(fallingBrick.getBrick(), x, y);
        return;
    }
}
